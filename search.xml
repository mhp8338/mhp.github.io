<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux Shell常用命令</title>
    <url>/2020/01/08/Linux-Shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-Linux-shell-命令"><a href="#1-Linux-shell-命令" class="headerlink" title="1 Linux shell 命令"></a>1 Linux shell 命令</h1><p>切换root：<code>sudo -i</code><br>切换hadoop: <code>su hadoop</code></p>
<p>查看centos的版本：<code>uname -a</code></p>
<p>下载：<code>wget</code> —</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop入门（二）—— 搭建单节点的Hadoop环境</title>
    <url>/2020/01/08/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%90%AD%E5%BB%BA%E5%8D%95%E8%8A%82%E7%82%B9%E7%9A%84Hadoop%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="1-Hadoop入门（二）——-搭建单节点的Hadoop环境"><a href="#1-Hadoop入门（二）——-搭建单节点的Hadoop环境" class="headerlink" title="1 Hadoop入门（二）—— 搭建单节点的Hadoop环境"></a>1 Hadoop入门（二）—— 搭建单节点的Hadoop环境</h1><ul>
<li>服务器环境：centos 7</li>
<li>客户端环境：Mac shell</li>
<li>ssh 连接:<br><code>ssh username@ip</code></li>
</ul>
<p><code>mkdir</code>创建文件夹：</p>
<table>
<thead>
<tr>
<th>filename</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>app</td>
<td>存放使用的软件安装包</td>
</tr>
<tr>
<td>app</td>
<td>存放使用的软件安装目录</td>
</tr>
<tr>
<td>data</td>
<td>存放使用的数据</td>
</tr>
<tr>
<td>lib</td>
<td>存放需求的jar存放的目录</td>
</tr>
<tr>
<td>shell</td>
<td>存放脚本</td>
</tr>
<tr>
<td>maven_resp</td>
<td>存放maven的依赖包目录</td>
</tr>
</tbody>
</table>
<h2 id="1-1-配置hostname"><a href="#1-1-配置hostname" class="headerlink" title="1.1 配置hostname"></a>1.1 配置hostname</h2><p>配置服务器的hostname：<code>sudo vim /etc/hosts</code></p>
<pre><code class="bash">192.168.215.100 hadoop000
127.0.0.1 localhost
</code></pre>
<p>建立hadoop000与IP的映射，可以直接通过hadoop000访问服务器</p>
<h2 id="1-2-hadoop-相关环境搭建"><a href="#1-2-hadoop-相关环境搭建" class="headerlink" title="1.2 hadoop 相关环境搭建"></a>1.2 hadoop 相关环境搭建</h2><p>1) Hadoop使用版本：CDH 版本 <a href="https://archive.cloudera.com/cdh5/cdh/5/" title="hadoop-2.6.0-cdh5.15.1/" target="_blank" rel="noopener">hadoop-2.6.0-cdh5.15.1</a><br>2) 版本的尾号必须相同: <code>cdh5.15.1</code><br>3) Hive的使用版本：hive-1.1.0-cdh5.15.1<br>4) java: 1.8<br>5) ssh</p>
<h2 id="1-3-JDK-1-8环境部署"><a href="#1-3-JDK-1-8环境部署" class="headerlink" title="1.3 JDK 1.8环境部署"></a>1.3 JDK 1.8环境部署</h2><p>1) 从本地拷贝至服务器<br>2) 解压<br>3) 配置环境变量,修改配置文件<br>4) 生效</p>
<pre><code class="bash">scp jdk-8u91-linux-x64.tar.gz hadoop@ip:~/software/
tar -zxvf hadoop-2.6.0-cdh5.15.1.tar.gz -C ~/app/
sudo vim .bash_profile
source .bash_profile
</code></pre>
<pre><code class="bash"># .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/.local/bin:$HOME/bin


export JAVA_HOME=/home/hadoop/app/jdk1.8.0_91
export PATH=$JAVA_HOME/bin:$PATH

export HADOOP_HOME=/home/hadoop/app/hadoop-2.6.0-cdh5.15.1
export PATH=$HADOOP_HOME/bin:$PATH

export HIVE_HOME=/home/hadoop/app/hive-1.1.0-cdh5.15.1
export PATH=$HIVE_HOME/bin:$PATH

export PATH
</code></pre>
]]></content>
      <categories>
        <category>Hadoop</category>
        <category>HDFS</category>
      </categories>
      <tags>
        <tag>Hadoop HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop入门（一）—— HDFS</title>
    <url>/2020/01/08/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94HDFS/</url>
    <content><![CDATA[<h1 id="1-Hadoop入门（一）——HDFS"><a href="#1-Hadoop入门（一）——HDFS" class="headerlink" title="1 Hadoop入门（一）——HDFS"></a>1 Hadoop入门（一）——HDFS</h1><h2 id="1-1-HDFS概述"><a href="#1-1-HDFS概述" class="headerlink" title="1.1 HDFS概述"></a>1.1 HDFS概述</h2><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" title="HDFS(Hadoop Distributed File System)" target="_blank" rel="noopener">HDFS(Hadoop Distributed File System)</a>:</p>
<ul>
<li>分布式</li>
<li>commodity hardware(可运行于廉价的硬件上)</li>
<li>fault-tolerant (具有容错性)</li>
<li>high throughout (高吞吐量)</li>
<li>large data sets (大数据集)</li>
</ul>
<h2 id="1-2-分布式文件系统"><a href="#1-2-分布式文件系统" class="headerlink" title="1.2 分布式文件系统"></a>1.2 分布式文件系统</h2><h3 id="1-2-1-传统文件系统特性"><a href="#1-2-1-传统文件系统特性" class="headerlink" title="1.2.1 传统文件系统特性"></a>1.2.1 传统文件系统特性</h3><p>Linux、Windows、Mac：</p>
<ul>
<li>根目录：/  C </li>
<li>存放的是文件或者文件夹</li>
<li>对外提供服务：创建、修改、删除、查看、移动等等</li>
</ul>
<h3 id="1-2-2-普通文件系统VS分布式文件系统"><a href="#1-2-2-普通文件系统VS分布式文件系统" class="headerlink" title="1.2.2 普通文件系统VS分布式文件系统"></a>1.2.2 普通文件系统VS分布式文件系统</h3><table>
<thead>
<tr>
<th>普通文件系统</th>
<th>分布式文件系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>单机操作</td>
<td>能够横跨N个机器</td>
</tr>
</tbody>
</table>
<h2 id="1-3-HDFS的前提和设计目标"><a href="#1-3-HDFS的前提和设计目标" class="headerlink" title="1.3 HDFS的前提和设计目标"></a>1.3 HDFS的前提和设计目标</h2><h3 id="Hardware-Failure"><a href="#Hardware-Failure" class="headerlink" title="Hardware Failure"></a>Hardware Failure</h3><p>硬件的故障，是一种常见异常，为了减少该异常的影响（也就是容错），每个机器只存储文件的一部分，即一个block。<strong>将一个文件拆分为多个block，然后分别打入不同的机器中</strong>。</p>
<h3 id="Streaming-Data-Access"><a href="#Streaming-Data-Access" class="headerlink" title="Streaming Data Access"></a>Streaming Data Access</h3><p>The emphasis is on high throughput of data access rather than low latency of data access.<br>高吞吐量而不是低延时——不适合做实时处理</p>
<h3 id="Large-Data-Sets"><a href="#Large-Data-Sets" class="headerlink" title="Large Data Sets"></a>Large Data Sets</h3><p>支持大规模数据存储，不怕数据大，怕数据小</p>
<h3 id="“Moving-Computation-is-Cheaper-than-Moving-Data”"><a href="#“Moving-Computation-is-Cheaper-than-Moving-Data”" class="headerlink" title="“Moving Computation is Cheaper than Moving Data”"></a>“Moving Computation is Cheaper than Moving Data”</h3><p>移动数据成本高 &gt;&gt; 移动计算省掉很多资源</p>
<h2 id="1-4-HDFS的架构"><a href="#1-4-HDFS的架构" class="headerlink" title="1.4 HDFS的架构"></a>1.4 HDFS的架构</h2><ul>
<li>NameNode(master) and DataNodes(slave)</li>
<li>master/slave architecture</li>
</ul>
<table>
<thead>
<tr>
<th>NameNode</th>
<th>DataNodes</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td>slave</td>
</tr>
<tr>
<td>name space</td>
<td>storage</td>
</tr>
<tr>
<td>管理文件系统</td>
<td>负责存储文件</td>
</tr>
<tr>
<td>提供客户端对文件的访问</td>
</tr>
</tbody>
</table>
<p>HDFS exposes a file system namespace and allows user data to be stored in files.</p>
<h3 id="1-4-1-内部实现"><a href="#1-4-1-内部实现" class="headerlink" title="1.4.1 内部实现"></a>1.4.1 内部实现</h3><p>1) a file is split into one or more blocks:<br> <code>blocksize: 128M</code><br><code>150M -&gt; 128M 22M</code><br>2) these blocks are stored in a set of DataNodes:<br>只为容错啊！</p>
<p>3) The NameNode executes file system namespace operations like opening, closing, and renaming files and directories :CRUD<br>4) determines the mapping of blocks to DataNodes<br>存放数据的具体位置信息，例如</p>
<table>
<thead>
<tr>
<th>a.txt</th>
<th>blocksize</th>
<th>replication</th>
</tr>
</thead>
<tbody>
<tr>
<td>150M</td>
<td>128M</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>namenode 存储如下关系，客户端通过该关系找到a.txt文件<br>block1 : 128M 192.168.199.1<br>block2 :   22M 192.168.199.2<br>GET a.txt  </p>
<p><strong>用户对该过程不感知</strong><br><img src="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/images/hdfsarchitecture.png" alt="NameNode and DataNodes" title="NameNode and DataNodes"></p>
<p>5)通常情况下，一个node部署一个机器，但也可以一台机器部署多个node</p>
<h2 id="1-5-文件系统namespace详解"><a href="#1-5-文件系统namespace详解" class="headerlink" title="1.5 文件系统namespace详解"></a>1.5 文件系统namespace详解</h2><blockquote>
<p>HDFS supports a traditional hierarchical file organization. A user or an application can create directories and store files inside these directories. The file system namespace hierarchy is similar to most other existing file systems; one can create and remove files, move a file from one directory to another, or rename a file. HDFS supports user quotas and access permissions. HDFS does not support hard links or soft links. However, the HDFS architecture does not preclude implementing these features.</p>
</blockquote>
<h2 id="1-6-Data-Replication"><a href="#1-6-Data-Replication" class="headerlink" title="1.6 Data Replication"></a>1.6 Data Replication</h2><blockquote>
<p>HDFS is designed to reliably store very large files across machines in a large cluster. It stores each file as a sequence of blocks. The blocks of a file are replicated for fault tolerance. The block size and replication factor are configurable per file.</p>
</blockquote>
<p><img src="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/images/hdfsdatanodes.png" alt="replication" title="replication"></p>
]]></content>
      <categories>
        <category>Hadoop</category>
        <category>HDFS</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(一)：单例模式</title>
    <url>/2019/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>保证一个类仅有一个实例，并提供一个全局的访问点。<br>类型：创建型<br>使用场景：确保任何情况下绝对仅有一个实例<br>线程池、数据库连接池</p>
<p>优点：仅有一个实例，减少内存开销<br>避免对资源文件多重占用<br>严格控制访问</p>
<p>缺点：无接口，拓展困难</p>
<p>重点：私有构造器、线程安全、延迟加载、序列化和反序列化安全、反射攻击</p>
<p>单例模式：懒汉式、饿汉式</p>
<h2 id="懒汉式单例设计模式"><a href="#懒汉式单例设计模式" class="headerlink" title="懒汉式单例设计模式"></a>懒汉式单例设计模式</h2><pre><code class="java">public class LazySingleton {
    /**
     * 初始化懒加载
     */
    private static LazySingleton lazySingleton = null;

    /**
     * 私有构造方法
     */
    private LazySingleton(){

    }

    /**
     * 静态方法public方法，获得实例
     * @return lazySingleton
     */
    public static LazySingleton getInstance(){
        if(lazySingleton == null){
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }

}
</code></pre>
<p>单线程可用，但多线程会破坏单例契约，线程不安全</p>
<pre><code class="java">public class LazySingletonTest {
    /**
     * 检测线程是否安全
     */

    public static void main( String[] args ) {
        //    LazySingleton lazySingleton = new LazySingleton(); 私有构造方法无法创建实例
        Thread t1 = new Thread( new T() );
        Thread t2 = new Thread( new T() );
        t1.start();
        t2.start();
        System.out.println(&quot;Program End...&quot;);
    }


}

</code></pre>
<pre><code class="java">public class T implements Runnable {
    @Override
    public void run() {
        LazySingleton lazySingleton = LazySingleton.getInstance();
        System.out.println(Thread.currentThread().getName()+ &quot;  &quot;+lazySingleton);
    }
}
</code></pre>
<p>Debug调试，令两个线程都溜入该单例模式的20行中，闷声发大财。<strong>两个线程均产生各自的对象</strong></p>
<pre><code class="shell">Thread-0  singleton.LazySingleton@15082754
Thread-1  singleton.LazySingleton@16fea746
Program End...
</code></pre>
<p><strong>改进</strong>：在方法中添加synchronized，锁定整个类，<strong>当一个线程创建单例时，会阻塞其他线程进入该类</strong><br>synchronized:</p>
<ul>
<li>加在到静态方法中，锁定整个class文件</li>
<li>加在非静态方法中，锁的是堆内存中的对象</li>
</ul>
<pre><code class="java">public synchronized static LazySingleton getInstance(){
        if(lazySingleton == null){
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }

public static LazySingleton getInstance(){
        synchronized(LazySingleton.class){
            if(lazySingleton == null){
                lazySingleton = new LazySingleton();
            }
        }
        return lazySingleton;
    }
</code></pre>
<p>###懒汉式单例模式进化——Double Check Lazy Singleton</p>
<pre><code class="java">public class LazyDoubleCheckSingleton {
    /**
     * volatile解决由重排序而产生的空指针异常，volatile中不允许重排序
     */
    private static volatile LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null;

    private LazyDoubleCheckSingleton(){

    }

    public static LazyDoubleCheckSingleton getInstance(){
        if(lazyDoubleCheckSingleton == null){
            synchronized ( LazyDoubleCheckSingleton.class ){
                if(lazyDoubleCheckSingleton == null){
                    /*
                     * 1.给对象分配内存
                     * 2.初始化对象
                     * 3.设置lazyDoubleCheckSingleton指向刚分配的内存地址
                     * 所有线程在执行java程序时必须要遵守intra-thread semantics
                     * 保证重排序不会改变单线程内的排序结果
                     *
                     */
                    lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton();
                }
            }
        }
        return lazyDoubleCheckSingleton;
    }
}
</code></pre>
<p>性能优化：</p>
<ul>
<li>添加判断，减少synchronize锁的使用</li>
<li>volatile修饰变量，解决由重排序而引起的空指针异常，解决方式是不允许重排序</li>
</ul>
<h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><pre><code class="java">public class StaticInnerClassSingleton {
    /**
     * 私有构造方法
     */
    private StaticInnerClassSingleton(){

    }

    /**
     * 静态内部类
     */
    private static class InnerClass{
    private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton();
    }

    /**
     * 获取方法
     * @return Instance
     */
    public static StaticInnerClassSingleton getInstance(){
        return InnerClass.staticInnerClassSingleton;
    }

}
</code></pre>
<p>原理：</p>
<ul>
<li>类初始化时将获得初始化锁，使得对象初始化的过程（重排序）对其他线程不可见。</li>
<li>基于类初始化的延迟单例解决方案</li>
</ul>
<h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p>饿汉式单例模式：类加载时就初始化完成，可以用final修饰，可用静态代码块的方式创建实例</p>
<pre><code class="java">public class HungrySingleton {
    /**
     * 创建实例，直接初始化
     */
//    private static final HungrySingleton hungrySingleton = new HungrySingleton();
    private static final HungrySingleton hungrySingleton;
    static {
        hungrySingleton = new HungrySingleton();
    }

    /**
     * 构造方法私有
     */
    private HungrySingleton(){

    }

    /**
     * 单例方法
     */
    public static HungrySingleton getInstance(){
        return hungrySingleton;
    }
}
</code></pre>
<ul>
<li>浪费资源</li>
<li>线程安全</li>
</ul>
<p><strong>序列化和反序列化破坏单例模式</strong><br><strong>反射破坏单例模式</strong>：无参构造方法的反射破坏——懒汉式无法防御</p>
<p>反射防御</p>
<p>枚举类实现单例模式</p>
]]></content>
      <tags>
        <tag>Design Mode</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池---骚操作</title>
    <url>/2019/12/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E9%AA%9A%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h2><ul>
<li>普通线程的启动方式</li>
<li>利用线程池启动线程的方式<br><a href="https://mhp8338.github.io/2019/12/11/hello-world/">Writing</a></li>
</ul>
<h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h2><ul>
<li>降低资源消耗：不用频繁创建销毁资源。</li>
<li>提高响应速度</li>
<li>提高线程可管理性</li>
</ul>
<h2 id="简单线程池的设计"><a href="#简单线程池的设计" class="headerlink" title="简单线程池的设计"></a>简单线程池的设计</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><h3 id="设计过程中需要思考的问题"><a href="#设计过程中需要思考的问题" class="headerlink" title="设计过程中需要思考的问题"></a>设计过程中需要思考的问题</h3><ol>
<li>初始创建线程数</li>
<li>没有可用线程的解决策略</li>
<li>缓冲数组长度</li>
<li>缓冲数组满了怎么办？</li>
</ol>
<h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><ul>
<li>corePoolSize</li>
<li>maxiumPoolSize</li>
<li>keepAliveTime</li>
<li>unit</li>
<li>workQueue</li>
<li>threadFactory</li>
<li>handle</li>
</ul>
<h2 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h2><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><ul>
<li>无界队列（链表）</li>
<li>有界的队列（链表、数组）</li>
<li>同步移交队列</li>
</ul>
<h2 id="线程池可选择的饱和策略"><a href="#线程池可选择的饱和策略" class="headerlink" title="线程池可选择的饱和策略"></a>线程池可选择的饱和策略</h2><ul>
<li>AbortPolicy终止策略(默认):抛异常，拒绝新任务</li>
<li>DiscardPolicy抛弃策略：抛弃新任务</li>
<li>DiscardOldestPolicy抛弃旧任务的策略：扔掉最旧的任务，添加新的任务</li>
<li>CallerRunsPolicy调用者运行的策略：提交任务的一方执行操作</li>
</ul>
<h2 id="线程池执行的示意图"><a href="#线程池执行的示意图" class="headerlink" title="线程池执行的示意图"></a>线程池执行的示意图</h2><h2 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h2><pre><code>Executors.newSingleThreadExecutor() //单一线程线程池
Executors.newCachedThreadPool() //线程数量无限线程池
Executors.newFixedThreadPool( 10 ) //线程数量固定的线程池
</code></pre><h2 id="向线程池提交任务的两种方式"><a href="#向线程池提交任务的两种方式" class="headerlink" title="向线程池提交任务的两种方式"></a>向线程池提交任务的两种方式</h2><ul>
<li>submit()</li>
<li>execute() 无法将值返回给主线程</li>
</ul>
<h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><ul>
<li>RUNNING</li>
<li>SHUTDOWN</li>
<li>STOP</li>
<li>TIDYING</li>
<li>TERMINATED</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Hello-Hexo"><a href="#Hello-Hexo" class="headerlink" title="Hello Hexo"></a>Hello Hexo</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>vim</title>
    <url>/2019/05/27/vim/</url>
    <content><![CDATA[<h1 id="（一）初始-vim"><a href="#（一）初始-vim" class="headerlink" title="（一）初始 vim"></a>（一）初始 vim</h1><h2 id="1-1-vim-编辑插入模式"><a href="#1-1-vim-编辑插入模式" class="headerlink" title="1.1 vim 编辑插入模式"></a>1.1 vim 编辑插入模式</h2><p>insert-&gt;normal:<code>esc</code><br>normal-&gt;insert:</p>
<ul>
<li><code>i:insert</code>光标前插入</li>
<li><code>a:append</code>光标后插入</li>
<li><code>o:open a line below</code>当前行的下一行插入</li>
<li><code>A:append after line</code>当前行最后插入</li>
<li><code>I:insert before line</code>当前行最前方插入</li>
<li><code>O:append a line above</code>当前行的上一行插入</li>
</ul>
<p>保存和退出:<code>wq</code></p>
<h2 id="1-2-vim-的多种模式"><a href="#1-2-vim-的多种模式" class="headerlink" title="1.2 vim 的多种模式"></a>1.2 vim 的多种模式</h2><ul>
<li>normal:<ul>
<li>各种命令操作和移动</li>
<li>大部分情况下在浏览而不是编辑</li>
</ul>
</li>
<li>insert：</li>
<li>command:<ul>
<li>保存和关闭<code>:wq</code></li>
<li>分屏：<code>:vs</code>(竖分屏 vertical screen) <code>:sp</code>(横分屏 split)</li>
<li>全局替换：<code>:s/foo/bar/g</code>-&gt;<code>:s/python/java/g</code></li>
</ul>
</li>
<li>visual:<ul>
<li>Normal 模式下<code>v</code>进入 visual</li>
<li>使用<code>V</code>选择行</li>
<li><code>ctrl+v</code>块状选择文本</li>
</ul>
</li>
</ul>
<h2 id="1-3-vim-插入模式技巧"><a href="#1-3-vim-插入模式技巧" class="headerlink" title="1.3 vim 插入模式技巧"></a>1.3 vim 插入模式技巧</h2><p><code>ctrl+h</code>:删除上一个字符<br><code>ctrl+w</code>:删除上一个单词<br><code>ctrl+u</code>:删除当前行<br><code>ctrl+[</code>:切换 esc<br><code>gi</code>:快速跳转到最后一次编辑的地方进入插入模式</p>
<h2 id="1-4-vim-快速移动"><a href="#1-4-vim-快速移动" class="headerlink" title="1.4 vim 快速移动"></a>1.4 vim 快速移动</h2><p><code>w/W</code>移动到下一个 word/WORD 开头<br><code>e/E</code>移动到下一个 word/WORD 结尾<br><code>b/B</code>移动到上一个 word/WORD 开头<br>WORD 以空白符分割的单词，word 以非空白符分割的单词<br>行间搜索移动：</p>
<ul>
<li><code>f/F</code>跳转到目标字符(前面搜索/后边搜索)</li>
<li><code>;/,</code>搜寻到下一个/上一个<br>水平移动:</li>
<li><code>0</code><strong>移动到行首</strong>，<code>^</code>移动到第一非空白字符=<strong><code>0+w</code></strong></li>
<li><code>$</code><strong>移动到行尾</strong>，<code>g_</code>移动到行尾非空白字符</li>
</ul>
<p>垂直移动：</p>
<ul>
<li><code>(</code>和<code>)</code>句子之间移动</li>
<li><code>{</code>和<code>}</code>段落之间移动</li>
</ul>
<p>页面移动：</p>
<ul>
<li><code>gg/G</code>移动到文件的开头和结尾，<code>ctrl+o</code>快速返回</li>
<li><code>H/M/L</code>跳转到屏幕的开头(Head)、中间(Middle)和结尾(Lower)</li>
<li><code>ctrl+u/f</code>上下翻页(upword,forword)</li>
<li><code>zz</code>把屏幕置于中间</li>
</ul>
<h2 id="1-5-vim的增删改查"><a href="#1-5-vim的增删改查" class="headerlink" title="1.5 vim的增删改查"></a>1.5 vim的增删改查</h2><h3 id="1-5-1-vim增加字符"><a href="#1-5-1-vim增加字符" class="headerlink" title="1.5.1 vim增加字符"></a>1.5.1 vim增加字符</h3><ul>
<li>增加字符就是插入模式</li>
<li>iao</li>
<li>IAO<h3 id="1-5-2-vim删减"><a href="#1-5-2-vim删减" class="headerlink" title="1.5.2 vim删减"></a>1.5.2 vim删减</h3></li>
<li>x也可以删除</li>
<li>daw删除单词</li>
<li>diw不删除空格</li>
<li>dd删除行</li>
<li>dt)删除右括号里的内容 </li>
<li>d配合visual模式的使用<h3 id="1-5-3-vim快速修改"><a href="#1-5-3-vim快速修改" class="headerlink" title="1.5.3 vim快速修改"></a>1.5.3 vim快速修改</h3>常用有三个：</li>
<li>c(change):配合文本删除字符进入插入模式<code>c+(a)+w</code> <code>C</code> <code>ctg</code></li>
<li>r(replace):快速修改</li>
<li>s(substitude):删除当前字符进入插入模式<h3 id="1-5-4-vim快速查询"><a href="#1-5-4-vim快速查询" class="headerlink" title="1.5.4 vim快速查询"></a>1.5.4 vim快速查询</h3>查询单词也是一种常用操作：</li>
<li>使用<code>\</code>或者<code>?</code>进行前向或者反向操作</li>
<li>使用<code>n</code>或者<code>N</code>跳转下一个或者上一个匹配</li>
<li>使用<code>*</code>或者<code>#</code>进行当前单词的前向和后向匹配 <h2 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h2></li>
</ul>
<p>vimrc 的几点说明：</p>
<ul>
<li>vimrc=vim run command</li>
<li>系统级 vimrc 和用户级 vimrc<ul>
<li>系统级：所用用户都生效</li>
<li>用户级：不同用户命令生效状态不同</li>
<li>每一行作为一个命令而执行</li>
</ul>
</li>
</ul>
<h2 id="vim删除"><a href="#vim删除" class="headerlink" title="vim删除"></a>vim删除</h2><ul>
<li><code>d$</code>删除光标后的改行部分</li>
</ul>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Java MySQL</title>
    <url>/2019/05/26/Java-MySQL/</url>
    <content><![CDATA[<h1 id="MySQL-数据库的简介"><a href="#MySQL-数据库的简介" class="headerlink" title="MySQL 数据库的简介"></a>MySQL 数据库的简介</h1><h2 id="1-1-MySQL-数据库的简介和安装"><a href="#1-1-MySQL-数据库的简介和安装" class="headerlink" title="1.1 MySQL 数据库的简介和安装"></a>1.1 MySQL 数据库的简介和安装</h2><h3 id="1-1-1-什么是数据库？"><a href="#1-1-1-什么是数据库？" class="headerlink" title="1.1.1 什么是数据库？"></a>1.1.1 什么是数据库？</h3><p>数据库是按数据结构来组织、存储和管理数据的仓库</p>
<h3 id="1-1-1-常见数据库"><a href="#1-1-1-常见数据库" class="headerlink" title="1.1.1 常见数据库"></a>1.1.1 常见数据库</h3><p>(甲骨文)Oracle、(IBM)DB2、(微软)SQL Server、Postgre SQL、MySQL。<br>MySQL 是典型的关系型数据管理系统</p>
<h3 id="1-1-2-相关术语"><a href="#1-1-2-相关术语" class="headerlink" title="1.1.2 相关术语"></a>1.1.2 相关术语</h3><p>数据库系统<code>Database System</code>简称 DBS，包含以下部分：</p>
<ul>
<li>数据库<code>Database</code></li>
<li>数据库管理系统<code>Database Manage System</code>DBMS</li>
<li>应用开发工具</li>
<li>管理员及用户</li>
</ul>
<h3 id="1-1-3-SQL-语言"><a href="#1-1-3-SQL-语言" class="headerlink" title="1.1.3 SQL 语言"></a>1.1.3 SQL 语言</h3><p>SQL(结构化查询语言 Structured Query Language)</p>
<ul>
<li>DDL:数据定义语言</li>
<li>DML:数据操控语言<ul>
<li>增</li>
<li>删</li>
<li>改</li>
</ul>
</li>
<li>DQL:数据查询语言<ul>
<li>查询用户</li>
</ul>
</li>
<li>DCL:数据控制语言<ul>
<li>控制用户权限</li>
</ul>
</li>
</ul>
<h2 id="1-2-MySQL-相关操作"><a href="#1-2-MySQL-相关操作" class="headerlink" title="1.2 MySQL 相关操作"></a>1.2 MySQL 相关操作</h2><h3 id="1-2-1-配置文件"><a href="#1-2-1-配置文件" class="headerlink" title="1.2.1 配置文件"></a>1.2.1 配置文件</h3><ul>
<li>隐藏文件</li>
<li>my.conf</li>
</ul>
<h3 id="1-2-2-登陆-退出-MySQL"><a href="#1-2-2-登陆-退出-MySQL" class="headerlink" title="1.2.2 登陆/退出 MySQL"></a>1.2.2 登陆/退出 MySQL</h3><p>登陆：</p>
<ul>
<li><code>mysql -uroot -p</code></li>
<li><code>mysql -uroot -p0623</code></li>
</ul>
<p>退出:</p>
<ul>
<li><code>exit</code></li>
<li><code>quit</code></li>
</ul>
<p>版本：</p>
<ul>
<li><code>mysql -V</code></li>
<li><code>mysql --version</code></li>
</ul>
<p>登陆信息中需要掌握：</p>
<ul>
<li>登陆过后命令行的结束符使用<code>;</code>或者是<code>\g</code></li>
<li>可以通过<code>help</code>、<code>\h</code>或<code>?</code>配合关键字查看帮助手册 </li>
<li><code>\c</code>可以取消当前命令的执行：<code>select user() \c</code></li>
</ul>
<h2 id="1-2-3-常用的SQL语句"><a href="#1-2-3-常用的SQL语句" class="headerlink" title="1.2.3 常用的SQL语句"></a>1.2.3 常用的SQL语句</h2><p><code>SELECT USER()</code>:得到登陆的用户<br><code>SELECT VERSION()</code>:得到mysql的版本信息<br><code>SELECT NOW()</code>:得到当前的日期时间<br><code>SELECT DATABASE()</code>:得到当前打开的数据</p>
<h2 id="1-2-4-SQL语句的语法规范"><a href="#1-2-4-SQL语句的语法规范" class="headerlink" title="1.2.4 SQL语句的语法规范"></a>1.2.4 SQL语句的语法规范</h2><ul>
<li>常用关键字需要大写，库名、表名和字段名称等需要小写</li>
<li>支持拆行操作，但不能把完整的单词拆开</li>
<li>数据库名称，表名称和字段名称不使用MySQL的保留字，如果必须使用<code>&#39;&#39;</code>将其括起来</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Learing Git</title>
    <url>/2019/05/23/Learing-Git/</url>
    <content><![CDATA[<h1 id="创建-Git-版本库"><a href="#创建-Git-版本库" class="headerlink" title="创建 Git 版本库"></a>创建 Git 版本库</h1><p>版本库就是一个目录，在该目录下所有文件都受 Git 的管理，Git 可以跟踪每个文件的修改和删除，任何时刻都可以追踪和还原。<br>具体过程如下：</p>
<ul>
<li>创建空目录<pre><code>  mkdir learngit
  cd learngit
</code></pre></li>
<li>将该目录变成 Git 所管理的仓库<pre><code>git init
</code></pre></li>
<li>编写 readme.txt</li>
<li>把文件添加仓库缓存区<code>stage</code><pre><code>git add readme.txt
</code></pre></li>
<li>提交更改，把缓存区内容提交至当前分支<code>master</code><pre><code>git commit -m &quot;wrote a readme file&quot;
</code></pre><img src="https://i.loli.net/2019/05/23/5ce6857441eb128759.jpg" alt="0.jpg"></li>
</ul>
<h1 id="修改-git-文件"><a href="#修改-git-文件" class="headerlink" title="修改 git 文件"></a>修改 git 文件</h1><ul>
<li>修改 readme.txt 文件</li>
<li>查看修改修改状态，但此时还未提交修改。并且只能显示已经修改，并未显示具体修改的内容<pre><code>git status
</code></pre></li>
<li>查看具体修改的内容<pre><code>git diff
</code></pre></li>
<li>添加<pre><code>git add readme.txt
git commit -m &quot;add distritbuted&quot;
</code></pre></li>
</ul>
<h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><ul>
<li>查看历史记录<pre><code>git log
git log --pretty=oneline
</code></pre></li>
<li>回退版本<pre><code>git reset --hard Head^
git reset --hard Head~100
</code></pre></li>
<li>还原版本<pre><code>git reset --hard {commit id}
</code></pre></li>
<li>查看文件<pre><code>cat readme.txt
</code></pre></li>
<li><p>查找之前每一次命令</p>
<pre><code>git reflog
</code></pre><h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1></li>
<li><p>提交缓存区</p>
<p><img src="https://i.loli.net/2019/05/23/5ce686ef3473670281.jpg" alt="1.jpg"></p>
</li>
<li><p>提交分支</p>
<p><img src="https://i.loli.net/2019/05/23/5ce6873f35e5257129.jpg" alt="2.jpg"></p>
</li>
</ul>
<blockquote>
<p>git管理修改，并非管理文件。<br>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
