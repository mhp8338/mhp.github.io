<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>菜鸟程序猿的小窝</title>
    <link>http://mhp.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 12 Jan 2020 09:32:01 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Hadoop入门（三）—— HDFS底层分析</title>
      <link>http://mhp.github.io/2020/01/12/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-HDFS%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/</link>
      <guid>http://mhp.github.io/2020/01/12/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-HDFS%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/</guid>
      <pubDate>Sun, 12 Jan 2020 09:01:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-Hadoop入门（三）——-HDFS底层分析&quot;&gt;&lt;a href=&quot;#1-Hadoop入门（三）——-HDFS底层分析&quot; class=&quot;headerlink&quot; title=&quot;1 Hadoop入门（三）—— HDFS底层分析&quot;&gt;&lt;/a&gt;1 Hadoop入门（三）—
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1-Hadoop入门（三）——-HDFS底层分析"><a href="#1-Hadoop入门（三）——-HDFS底层分析" class="headerlink" title="1 Hadoop入门（三）—— HDFS底层分析"></a>1 Hadoop入门（三）—— HDFS底层分析</h1><h2 id="1-1-副本摆放策略"><a href="#1-1-副本摆放策略" class="headerlink" title="1.1 副本摆放策略"></a>1.1 副本摆放策略</h2><p>机架感知摆放策略：<br>（1）同一机架内的节点通信方便，不需要交换机<br>（2）若将所有节点放入同一机架，则容错性将变得很差<br>（3）摆放策略如下：</p><pre><code>- 副本一 =&gt; 本rack的一个节点上- 副本二 =&gt; 另外一个rack的节点上- 副本三 =&gt; 与副本二相同rack的另外一个节点上</code></pre><p> （4）容错性较强，三个副本在两个rack上，提高读写效率</p><h2 id="1-2-HDFS写数据的流程"><a href="#1-2-HDFS写数据的流程" class="headerlink" title="1.2 HDFS写数据的流程"></a>1.2 HDFS写数据的流程</h2><p> 客户端写数据到hdfs的流程如图</p><p> <img src="/2020/01/12/Hadoop入门（三）——-HDFS底层分析/hdfs写数据.jpg" alt></p><h2 id="1-3-HDFS读数据的流程"><a href="#1-3-HDFS读数据的流程" class="headerlink" title="1.3 HDFS读数据的流程"></a>1.3 HDFS读数据的流程</h2><p> 客户端从hdfs读数据的流程如图</p><p> <img src="/2020/01/12/Hadoop入门（三）——-HDFS底层分析/HDFS读文件.jpg" alt></p><h2 id="1-4-HDFS-checkpoint详解"><a href="#1-4-HDFS-checkpoint详解" class="headerlink" title="1.4 HDFS checkpoint详解"></a>1.4 HDFS checkpoint详解</h2><p>hdfs的元数据管理：<br>元数据：hdfs的目录结构以及每个文件的block信息{id,replication,block_id}<br>存在什么地方：对应配置文件<code>{hadoop.tmp.dir}/name/..</code><br><strong>fsimage</strong>:定期将内存中的元数据序列化到磁盘<br><strong>edits</strong>:日志记录时间段内所有对hdfs的操作指令</p><h3 id="check-point"><a href="#check-point" class="headerlink" title="check point"></a><strong>check point</strong></h3><p>SecondNameNode:辅佐namenode合并<code>fsimage</code>和<code>edits</code></p><ul><li>先加载磁盘文件至内存，还原数据，反序列化——(磁盘)fsimage</li><li>将edits中的所有操作更新至内存中，此时SecondNameNode数据是完整的</li><li>将second name node写回磁盘，生成新的fsimage，并替换name node 的fsimage </li></ul><h2 id="1-5-safemode"><a href="#1-5-safemode" class="headerlink" title="1.5  safemode"></a>1.5  safemode</h2><p>启动前，namenode 将进入safemode状态，在此状态下块的复制（副本）将不会执行，无法进行数据的写操作<br>namenode将接受dn的心跳以及报告信息，认为健康（高于最低安全系数），此时就可以写和副本操作</p><p>一般为30s</p>]]></content:encoded>
      
      <comments>http://mhp.github.io/2020/01/12/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-HDFS%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux Shell常用命令</title>
      <link>http://mhp.github.io/2020/01/08/Linux-Shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <guid>http://mhp.github.io/2020/01/08/Linux-Shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Wed, 08 Jan 2020 10:50:52 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-Linux-shell-命令&quot;&gt;&lt;a href=&quot;#1-Linux-shell-命令&quot; class=&quot;headerlink&quot; title=&quot;1 Linux shell 命令&quot;&gt;&lt;/a&gt;1 Linux shell 命令&lt;/h1&gt;&lt;p&gt;切换root：&lt;code&gt;s
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1-Linux-shell-命令"><a href="#1-Linux-shell-命令" class="headerlink" title="1 Linux shell 命令"></a>1 Linux shell 命令</h1><p>切换root：<code>sudo -i</code><br>切换hadoop: <code>su hadoop</code></p><p>查看centos的版本：<code>uname -a</code></p><p>下载：<code>wget</code> —</p>]]></content:encoded>
      
      <comments>http://mhp.github.io/2020/01/08/Linux-Shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hadoop入门（二）—— 搭建单节点的Hadoop环境</title>
      <link>http://mhp.github.io/2020/01/08/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%90%AD%E5%BB%BA%E5%8D%95%E8%8A%82%E7%82%B9%E7%9A%84Hadoop%E7%8E%AF%E5%A2%83/</link>
      <guid>http://mhp.github.io/2020/01/08/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%90%AD%E5%BB%BA%E5%8D%95%E8%8A%82%E7%82%B9%E7%9A%84Hadoop%E7%8E%AF%E5%A2%83/</guid>
      <pubDate>Wed, 08 Jan 2020 10:48:51 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-Hadoop入门（二）——-搭建单节点的Hadoop环境&quot;&gt;&lt;a href=&quot;#1-Hadoop入门（二）——-搭建单节点的Hadoop环境&quot; class=&quot;headerlink&quot; title=&quot;1 Hadoop入门（二）—— 搭建单节点的Hadoop环境&quot;&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1-Hadoop入门（二）——-搭建单节点的Hadoop环境"><a href="#1-Hadoop入门（二）——-搭建单节点的Hadoop环境" class="headerlink" title="1 Hadoop入门（二）—— 搭建单节点的Hadoop环境"></a>1 Hadoop入门（二）—— 搭建单节点的Hadoop环境</h1><ul><li>服务器环境：centos 7</li><li>客户端环境：Mac shell</li><li>ssh 连接:<br><code>ssh username@ip</code></li></ul><p><code>mkdir</code>创建文件夹：</p><table><thead><tr><th>filename</th><th>description</th></tr></thead><tbody><tr><td>app</td><td>存放使用的软件安装包</td></tr><tr><td>app</td><td>存放使用的软件安装目录</td></tr><tr><td>data</td><td>存放使用的数据</td></tr><tr><td>lib</td><td>存放需求的jar存放的目录</td></tr><tr><td>shell</td><td>存放脚本</td></tr><tr><td>maven_resp</td><td>存放maven的依赖包目录</td></tr></tbody></table><h2 id="1-1-配置hostname"><a href="#1-1-配置hostname" class="headerlink" title="1.1 配置hostname"></a>1.1 配置hostname</h2><p>配置服务器的hostname：<code>sudo vim /etc/hosts</code></p><pre><code class="bash">192.168.215.100 hadoop000127.0.0.1 localhost</code></pre><p>建立hadoop000与IP的映射，可以直接通过hadoop000访问服务器</p><h2 id="1-2-hadoop-相关环境搭建"><a href="#1-2-hadoop-相关环境搭建" class="headerlink" title="1.2 hadoop 相关环境搭建"></a>1.2 hadoop 相关环境搭建</h2><p>1) Hadoop使用版本：CDH 版本 <a href="https://archive.cloudera.com/cdh5/cdh/5/" title="hadoop-2.6.0-cdh5.15.1/" target="_blank" rel="noopener">hadoop-2.6.0-cdh5.15.1</a><br>2) 版本的尾号必须相同: <code>cdh5.15.1</code><br>3) Hive的使用版本：hive-1.1.0-cdh5.15.1<br>4) java: 1.8<br>5) ssh</p><h2 id="1-3-JDK-1-8环境部署"><a href="#1-3-JDK-1-8环境部署" class="headerlink" title="1.3 JDK 1.8环境部署"></a>1.3 JDK 1.8环境部署</h2><p>1) 从本地拷贝至服务器<br>2) 解压<br>3) 配置环境变量,修改配置文件<br>4) 生效<br>5) 验证</p><pre><code class="bash">scp jdk-8u91-linux-x64.tar.gz hadoop@ip:~/software/tar -zxvf hadoop-2.6.0-cdh5.15.1.tar.gz -C ~/app/sudo vim .bash_profilesource .bash_profilejava -version</code></pre><pre><code class="bash"># .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then        . ~/.bashrcfi# User specific environment and startup programsPATH=$PATH:$HOME/.local/bin:$HOME/binexport JAVA_HOME=/home/hadoop/app/jdk1.8.0_91export PATH=$JAVA_HOME/bin:$PATHexport HADOOP_HOME=/home/hadoop/app/hadoop-2.6.0-cdh5.15.1export PATH=$HADOOP_HOME/bin:$PATHexport HIVE_HOME=/home/hadoop/app/hive-1.1.0-cdh5.15.1export PATH=$HIVE_HOME/bin:$PATHexport PATH</code></pre><h2 id="1-4-ssh无密码登陆部署"><a href="#1-4-ssh无密码登陆部署" class="headerlink" title="1.4 ssh无密码登陆部署"></a>1.4 ssh无密码登陆部署</h2><p><code>ssh hadoop000</code>每一次登陆都需要密码，影响主从节点通信</p><p>输入：<code>ssh-keygen -t rsa</code><br>进入：<code>cd ~/.ssh</code></p><pre><code class="shell">-rw------- 1 hadoop hadoop  398 10月 15 2018 authorized_keys-rw------- 1 hadoop hadoop 1679 10月 15 2018 id_rsa //私钥-rw-r--r-- 1 hadoop hadoop  398 10月 15 2018 id_rsa.pub //公钥-rw-r--r-- 1 hadoop hadoop 1060 1月   7 23:54 known_hosts</code></pre><p>将公钥写入authorized_keys</p><pre><code class="shell">cat id_rsa.pub &gt;&gt; authorized_keys#修改authorized_keys权限chmod 600 authorized_keys</code></pre><h2 id="1-5-Hadoop-安装"><a href="#1-5-Hadoop-安装" class="headerlink" title="1.5 Hadoop 安装"></a>1.5 Hadoop 安装</h2><p>1) 下载<br>2) 解压:<code>~/app</code><br>3)添加$HADOOP_HOME/bin到系统环境变量</p><h3 id="1-5-1-hadooop软件包常见目录说明"><a href="#1-5-1-hadooop软件包常见目录说明" class="headerlink" title="1.5.1 hadooop软件包常见目录说明"></a>1.5.1 hadooop软件包常见目录说明</h3><pre><code class="shell">drwxr-xr-x  2 hadoop hadoop   137 8月  10 2018 bindrwxr-xr-x  2 hadoop hadoop   166 8月  10 2018 bin-mapreduce1drwxr-xr-x  3 hadoop hadoop  4096 10月 15 2018 clouderadrwxr-xr-x  6 hadoop hadoop   109 8月  10 2018 etcdrwxr-xr-x  5 hadoop hadoop    43 8月  10 2018 examplesdrwxr-xr-x  3 hadoop hadoop    28 8月  10 2018 examples-mapreduce1drwxr-xr-x  2 hadoop hadoop   106 8月  10 2018 includedrwxr-xr-x  3 hadoop hadoop    20 8月  10 2018 libdrwxr-xr-x  3 hadoop hadoop   261 8月  10 2018 libexec-rw-r--r--  1 hadoop hadoop 85063 8月  10 2018 LICENSE.txtdrwxrwxr-x  3 hadoop hadoop  4096 12月  8 2018 logs-rw-r--r--  1 hadoop hadoop 14978 8月  10 2018 NOTICE.txt-rw-r--r--  1 hadoop hadoop  1366 8月  10 2018 README.txtdrwxr-xr-x  3 hadoop hadoop  4096 8月  10 2018 sbindrwxr-xr-x  4 hadoop hadoop    31 8月  10 2018 sharedrwxr-xr-x 18 hadoop hadoop  4096 8月  10 2018 src</code></pre><table><thead><tr><th>软件包</th><th>目录说明</th></tr></thead><tbody><tr><td>bin</td><td>hadoop客户端命令</td></tr><tr><td>etc</td><td>hadoop相关的配置文件</td></tr><tr><td>sbin</td><td>启动Hadoop相关进程的脚本</td></tr><tr><td>examples</td><td>存放案例</td></tr><tr><td>lib</td><td>依赖包</td></tr><tr><td>share</td><td>常用例子</td></tr></tbody></table><h3 id="1-5-2-Hadoop配置"><a href="#1-5-2-Hadoop配置" class="headerlink" title="1.5.2 Hadoop配置"></a>1.5.2 Hadoop配置</h3><p>1) Hadoop-env.sh： 配置Java<br>2) 配置默认的文件系统(主节点)：core-site.xml</p><pre><code class="xml">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://hadoop:8020&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>3) 配置副本系数(单节点)：hdfs-site.xml</p><pre><code class="xml">&lt;configuration&gt;   &lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>4) 修改临时文件的base目录</p><pre><code class="xml">&lt;configuration&gt;   &lt;property&gt;        &lt;name&gt;hadoop.tem.dir&lt;/name&gt;        &lt;value&gt;/home/hadoop/app/tmp&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>5) 修改从节点:<code>hadoop000</code></p><h3 id="1-5-3-启动hdfs"><a href="#1-5-3-启动hdfs" class="headerlink" title="1.5.3 启动hdfs"></a>1.5.3 启动hdfs</h3><p><strong>第一次执行时一定要格式化文件系统，后期不可重复执行</strong></p><pre><code class="shell">hdfs namenode -format</code></pre><p>启动服务：<code>sbin</code>目录下</p><pre><code class="shell">./start-dfs.sh</code></pre><p>验证：<br>(1)三个节点</p><pre><code class="shell">jps20720 NameNode21047 SecondaryNameNode21181 Jps20830 DataNode</code></pre><p>如果出现错误：查看日志 <code>/home/hadoop/app/hadoop-2.6.0-cdh5.15.1/logs</code><br>(2) 浏览器验证<br>192.168.215.100:50070 =&gt;关闭防火墙</p><pre><code class="shell">#查看防火墙状态firewall-cmd --state#关闭防火墙systemctl stop firewalld.service#禁止防火墙开机启动systemctl disable firewalld.service</code></pre><h3 id="1-5-4-停止集群以及单个节点启动"><a href="#1-5-4-停止集群以及单个节点启动" class="headerlink" title="1.5.4 停止集群以及单个节点启动"></a>1.5.4 停止集群以及单个节点启动</h3><p>停止dfs：<code>./stop-dfs.sh</code><br>开启某一线程：<code>./hadoop-daemon.sh start namenode</code></p><p>start/stop-dfs.sh与hadoop-daemon.sh的关系：<br>start-dfs.sh =&gt; </p><ul><li>hadoop-daemon.sh start namenode </li><li>hadoop-daemon.sh start datanode </li><li>hadoop-daemon.sh start secondarynamenode</li></ul><h2 id="1-6-HDFS命令行操作"><a href="#1-6-HDFS命令行操作" class="headerlink" title="1.6 HDFS命令行操作"></a>1.6 HDFS命令行操作</h2><p><code>bin</code>目录下的执行<br>hadoop fs [generic options]</p><pre><code class="shell">    [-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;]     [-cat [-ignoreCrc] &lt;src&gt; ...]    [-checksum &lt;src&gt; ...]    [-chgrp [-R] GROUP PATH...]    [-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; PATH...]    [-chown [-R] [OWNER][:[GROUP]] PATH...]    [-copyFromLocal [-f] [-p] [-l] &lt;localsrc&gt; ... &lt;dst&gt;]    [-copyToLocal [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]    [-count [-q] [-h] [-v] [-x] &lt;path&gt; ...]    [-cp [-f] [-p | -p[topax]] &lt;src&gt; ... &lt;dst&gt;]    [-createSnapshot &lt;snapshotDir&gt; [&lt;snapshotName&gt;]]    [-deleteSnapshot &lt;snapshotDir&gt; &lt;snapshotName&gt;]    [-df [-h] [&lt;path&gt; ...]]    [-du [-s] [-h] [-x] &lt;path&gt; ...]    [-expunge]    [-find &lt;path&gt; ... &lt;expression&gt; ...]    [-get [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]    [-getfacl [-R] &lt;path&gt;]    [-getfattr [-R] {-n name | -d} [-e en] &lt;path&gt;]    [-getmerge [-nl] &lt;src&gt; &lt;localdst&gt;]    [-help [cmd ...]]    [-ls [-C] [-d] [-h] [-q] [-R] [-t] [-S] [-r] [-u] [&lt;path&gt; ...]]    [-mkdir [-p] &lt;path&gt; ...]    [-moveFromLocal &lt;localsrc&gt; ... &lt;dst&gt;]    [-moveToLocal &lt;src&gt; &lt;localdst&gt;]    [-mv &lt;src&gt; ... &lt;dst&gt;]    [-put [-f] [-p] [-l] &lt;localsrc&gt; ... &lt;dst&gt;]    [-renameSnapshot &lt;snapshotDir&gt; &lt;oldName&gt; &lt;newName&gt;]    [-rm [-f] [-r|-R] [-skipTrash] &lt;src&gt; ...]    [-rmdir [--ignore-fail-on-non-empty] &lt;dir&gt; ...]    [-setfacl [-R] [{-b|-k} {-m|-x &lt;acl_spec&gt;} &lt;path&gt;]|[--set &lt;acl_spec&gt; &lt;path&gt;]]    [-setfattr {-n name [-v value] | -x name} &lt;path&gt;]    [-setrep [-R] [-w] &lt;rep&gt; &lt;path&gt; ...]    [-stat [format] &lt;path&gt; ...]    [-tail [-f] &lt;file&gt;]    [-test -[defsz] &lt;path&gt;]    [-text [-ignoreCrc] &lt;src&gt; ...]    [-touchz &lt;path&gt; ...]    [-usage [cmd ...]]</code></pre><pre><code class="bash">hadoop fs -ls /hadoop fs -put README.txt /hadoop fs -cat /README.txthadoop fs -text /README.txthadoop fs -copyFromLocal excludes.txt /hadoop fs -moveFromLocal /hadoop fs -get /README.txt .hadoop fs -mkdir /test1hadoop fs -mv /README.txt /test1hadoop fs -cp /test1/README.txt /test1/README.txt-bakhadoop fs -getmerge /test1 ./mmm.txthadoop fs -rm  /test1/README.txt-bakhadoop fs -rm -r  /test1hadoop fs -rmdir  /test1</code></pre><h2 id="1-7-hdfs文件的存储机制"><a href="#1-7-hdfs文件的存储机制" class="headerlink" title="1.7 hdfs文件的存储机制"></a>1.7 hdfs文件的存储机制</h2><p>文件到底在哪：<br><code>tmp/dfs/data/current/BP-28074851-192.168.199.233-1539551174228/current/finalized/subdir0/subdir3</code></p><ul><li>PUT: 1 file =&gt; 1..n block =&gt;存放在不同节点</li><li>GET: 去nn上查找这个文件的愿数据信息</li></ul><p>hdfs: 拆文件组装文件的过程</p>]]></content:encoded>
      
      <comments>http://mhp.github.io/2020/01/08/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%90%AD%E5%BB%BA%E5%8D%95%E8%8A%82%E7%82%B9%E7%9A%84Hadoop%E7%8E%AF%E5%A2%83/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hadoop入门（一）—— HDFS</title>
      <link>http://mhp.github.io/2020/01/08/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94HDFS/</link>
      <guid>http://mhp.github.io/2020/01/08/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94HDFS/</guid>
      <pubDate>Wed, 08 Jan 2020 08:05:08 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-Hadoop入门（一）——HDFS&quot;&gt;&lt;a href=&quot;#1-Hadoop入门（一）——HDFS&quot; class=&quot;headerlink&quot; title=&quot;1 Hadoop入门（一）——HDFS&quot;&gt;&lt;/a&gt;1 Hadoop入门（一）——HDFS&lt;/h1&gt;&lt;h2 i
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1-Hadoop入门（一）——HDFS"><a href="#1-Hadoop入门（一）——HDFS" class="headerlink" title="1 Hadoop入门（一）——HDFS"></a>1 Hadoop入门（一）——HDFS</h1><h2 id="1-1-HDFS概述"><a href="#1-1-HDFS概述" class="headerlink" title="1.1 HDFS概述"></a>1.1 HDFS概述</h2><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" title="HDFS(Hadoop Distributed File System)" target="_blank" rel="noopener">HDFS(Hadoop Distributed File System)</a>:</p><ul><li>分布式</li><li>commodity hardware(可运行于廉价的硬件上)</li><li>fault-tolerant (具有容错性)</li><li>high throughout (高吞吐量)</li><li>large data sets (大数据集)</li></ul><h2 id="1-2-分布式文件系统"><a href="#1-2-分布式文件系统" class="headerlink" title="1.2 分布式文件系统"></a>1.2 分布式文件系统</h2><h3 id="1-2-1-传统文件系统特性"><a href="#1-2-1-传统文件系统特性" class="headerlink" title="1.2.1 传统文件系统特性"></a>1.2.1 传统文件系统特性</h3><p>Linux、Windows、Mac：</p><ul><li>根目录：/  C </li><li>存放的是文件或者文件夹</li><li>对外提供服务：创建、修改、删除、查看、移动等等</li></ul><h3 id="1-2-2-普通文件系统VS分布式文件系统"><a href="#1-2-2-普通文件系统VS分布式文件系统" class="headerlink" title="1.2.2 普通文件系统VS分布式文件系统"></a>1.2.2 普通文件系统VS分布式文件系统</h3><table><thead><tr><th>普通文件系统</th><th>分布式文件系统</th></tr></thead><tbody><tr><td>单机操作</td><td>能够横跨N个机器</td></tr></tbody></table><h2 id="1-3-HDFS的前提和设计目标"><a href="#1-3-HDFS的前提和设计目标" class="headerlink" title="1.3 HDFS的前提和设计目标"></a>1.3 HDFS的前提和设计目标</h2><h3 id="Hardware-Failure"><a href="#Hardware-Failure" class="headerlink" title="Hardware Failure"></a>Hardware Failure</h3><p>硬件的故障，是一种常见异常，为了减少该异常的影响（也就是容错），每个机器只存储文件的一部分，即一个block。<strong>将一个文件拆分为多个block，然后分别打入不同的机器中</strong>。</p><h3 id="Streaming-Data-Access"><a href="#Streaming-Data-Access" class="headerlink" title="Streaming Data Access"></a>Streaming Data Access</h3><p>The emphasis is on high throughput of data access rather than low latency of data access.<br>高吞吐量而不是低延时——不适合做实时处理</p><h3 id="Large-Data-Sets"><a href="#Large-Data-Sets" class="headerlink" title="Large Data Sets"></a>Large Data Sets</h3><p>支持大规模数据存储，不怕数据大，怕数据小</p><h3 id="“Moving-Computation-is-Cheaper-than-Moving-Data”"><a href="#“Moving-Computation-is-Cheaper-than-Moving-Data”" class="headerlink" title="“Moving Computation is Cheaper than Moving Data”"></a>“Moving Computation is Cheaper than Moving Data”</h3><p>移动数据成本高 &gt;&gt; 移动计算省掉很多资源</p><h2 id="1-4-HDFS的架构"><a href="#1-4-HDFS的架构" class="headerlink" title="1.4 HDFS的架构"></a>1.4 HDFS的架构</h2><ul><li>NameNode(master) and DataNodes(slave)</li><li>master/slave architecture</li></ul><table><thead><tr><th>NameNode</th><th>DataNodes</th></tr></thead><tbody><tr><td>master</td><td>slave</td></tr><tr><td>name space</td><td>storage</td></tr><tr><td>管理文件系统</td><td>负责存储文件</td></tr><tr><td>提供客户端对文件的访问</td></tr></tbody></table><p>HDFS exposes a file system namespace and allows user data to be stored in files.</p><h3 id="1-4-1-内部实现"><a href="#1-4-1-内部实现" class="headerlink" title="1.4.1 内部实现"></a>1.4.1 内部实现</h3><p>1) a file is split into one or more blocks:<br> <code>blocksize: 128M</code><br><code>150M -&gt; 128M 22M</code><br>2) these blocks are stored in a set of DataNodes:<br>只为容错啊！</p><p>3) The NameNode executes file system namespace operations like opening, closing, and renaming files and directories :CRUD<br>4) determines the mapping of blocks to DataNodes<br>存放数据的具体位置信息，例如</p><table><thead><tr><th>a.txt</th><th>blocksize</th><th>replication</th></tr></thead><tbody><tr><td>150M</td><td>128M</td><td>1</td></tr></tbody></table><p>namenode 存储如下关系，客户端通过该关系找到a.txt文件<br>block1 : 128M 192.168.199.1<br>block2 :   22M 192.168.199.2<br>GET a.txt  </p><p><strong>用户对该过程不感知</strong><br><img src="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/images/hdfsarchitecture.png" alt="NameNode and DataNodes" title="NameNode and DataNodes"></p><p>5)通常情况下，一个node部署一个机器，但也可以一台机器部署多个node</p><h2 id="1-5-文件系统namespace详解"><a href="#1-5-文件系统namespace详解" class="headerlink" title="1.5 文件系统namespace详解"></a>1.5 文件系统namespace详解</h2><blockquote><p>HDFS supports a traditional hierarchical file organization. A user or an application can create directories and store files inside these directories. The file system namespace hierarchy is similar to most other existing file systems; one can create and remove files, move a file from one directory to another, or rename a file. HDFS supports user quotas and access permissions. HDFS does not support hard links or soft links. However, the HDFS architecture does not preclude implementing these features.</p></blockquote><h2 id="1-6-Data-Replication"><a href="#1-6-Data-Replication" class="headerlink" title="1.6 Data Replication"></a>1.6 Data Replication</h2><blockquote><p>HDFS is designed to reliably store very large files across machines in a large cluster. It stores each file as a sequence of blocks. The blocks of a file are replicated for fault tolerance. The block size and replication factor are configurable per file.</p></blockquote><p><img src="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/images/hdfsdatanodes.png" alt="replication" title="replication"></p>]]></content:encoded>
      
      <comments>http://mhp.github.io/2020/01/08/Hadoop%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94HDFS/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式(一)：单例模式</title>
      <link>http://mhp.github.io/2019/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <guid>http://mhp.github.io/2019/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <pubDate>Sat, 14 Dec 2019 07:10:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;单例设计模式&quot;&gt;&lt;a href=&quot;#单例设计模式&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式&quot;&gt;&lt;/a&gt;单例设计模式&lt;/h1&gt;&lt;p&gt;保证一个类仅有一个实例，并提供一个全局的访问点。&lt;br&gt;类型：创建型&lt;br&gt;使用场景：确保任何情况下绝对仅有
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>保证一个类仅有一个实例，并提供一个全局的访问点。<br>类型：创建型<br>使用场景：确保任何情况下绝对仅有一个实例<br>线程池、数据库连接池</p><p>优点：仅有一个实例，减少内存开销<br>避免对资源文件多重占用<br>严格控制访问</p><p>缺点：无接口，拓展困难</p><p>重点：私有构造器、线程安全、延迟加载、序列化和反序列化安全、反射攻击</p><p>单例模式：懒汉式、饿汉式</p><h2 id="懒汉式单例设计模式"><a href="#懒汉式单例设计模式" class="headerlink" title="懒汉式单例设计模式"></a>懒汉式单例设计模式</h2><pre><code class="java">public class LazySingleton {    /**     * 初始化懒加载     */    private static LazySingleton lazySingleton = null;    /**     * 私有构造方法     */    private LazySingleton(){    }    /**     * 静态方法public方法，获得实例     * @return lazySingleton     */    public static LazySingleton getInstance(){        if(lazySingleton == null){            lazySingleton = new LazySingleton();        }        return lazySingleton;    }}</code></pre><p>单线程可用，但多线程会破坏单例契约，线程不安全</p><pre><code class="java">public class LazySingletonTest {    /**     * 检测线程是否安全     */    public static void main( String[] args ) {        //    LazySingleton lazySingleton = new LazySingleton(); 私有构造方法无法创建实例        Thread t1 = new Thread( new T() );        Thread t2 = new Thread( new T() );        t1.start();        t2.start();        System.out.println(&quot;Program End...&quot;);    }}</code></pre><pre><code class="java">public class T implements Runnable {    @Override    public void run() {        LazySingleton lazySingleton = LazySingleton.getInstance();        System.out.println(Thread.currentThread().getName()+ &quot;  &quot;+lazySingleton);    }}</code></pre><p>Debug调试，令两个线程都溜入该单例模式的20行中，闷声发大财。<strong>两个线程均产生各自的对象</strong></p><pre><code class="shell">Thread-0  singleton.LazySingleton@15082754Thread-1  singleton.LazySingleton@16fea746Program End...</code></pre><p><strong>改进</strong>：在方法中添加synchronized，锁定整个类，<strong>当一个线程创建单例时，会阻塞其他线程进入该类</strong><br>synchronized:</p><ul><li>加在到静态方法中，锁定整个class文件</li><li>加在非静态方法中，锁的是堆内存中的对象</li></ul><pre><code class="java">public synchronized static LazySingleton getInstance(){        if(lazySingleton == null){            lazySingleton = new LazySingleton();        }        return lazySingleton;    }public static LazySingleton getInstance(){        synchronized(LazySingleton.class){            if(lazySingleton == null){                lazySingleton = new LazySingleton();            }        }        return lazySingleton;    }</code></pre><p>###懒汉式单例模式进化——Double Check Lazy Singleton</p><pre><code class="java">public class LazyDoubleCheckSingleton {    /**     * volatile解决由重排序而产生的空指针异常，volatile中不允许重排序     */    private static volatile LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null;    private LazyDoubleCheckSingleton(){    }    public static LazyDoubleCheckSingleton getInstance(){        if(lazyDoubleCheckSingleton == null){            synchronized ( LazyDoubleCheckSingleton.class ){                if(lazyDoubleCheckSingleton == null){                    /*                     * 1.给对象分配内存                     * 2.初始化对象                     * 3.设置lazyDoubleCheckSingleton指向刚分配的内存地址                     * 所有线程在执行java程序时必须要遵守intra-thread semantics                     * 保证重排序不会改变单线程内的排序结果                     *                     */                    lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton();                }            }        }        return lazyDoubleCheckSingleton;    }}</code></pre><p>性能优化：</p><ul><li>添加判断，减少synchronize锁的使用</li><li>volatile修饰变量，解决由重排序而引起的空指针异常，解决方式是不允许重排序</li></ul><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><pre><code class="java">public class StaticInnerClassSingleton {    /**     * 私有构造方法     */    private StaticInnerClassSingleton(){    }    /**     * 静态内部类     */    private static class InnerClass{    private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton();    }    /**     * 获取方法     * @return Instance     */    public static StaticInnerClassSingleton getInstance(){        return InnerClass.staticInnerClassSingleton;    }}</code></pre><p>原理：</p><ul><li>类初始化时将获得初始化锁，使得对象初始化的过程（重排序）对其他线程不可见。</li><li>基于类初始化的延迟单例解决方案</li></ul><h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p>饿汉式单例模式：类加载时就初始化完成，可以用final修饰，可用静态代码块的方式创建实例</p><pre><code class="java">public class HungrySingleton {    /**     * 创建实例，直接初始化     *///    private static final HungrySingleton hungrySingleton = new HungrySingleton();    private static final HungrySingleton hungrySingleton;    static {        hungrySingleton = new HungrySingleton();    }    /**     * 构造方法私有     */    private HungrySingleton(){    }    /**     * 单例方法     */    public static HungrySingleton getInstance(){        return hungrySingleton;    }}</code></pre><ul><li>浪费资源</li><li>线程安全</li></ul><p><strong>序列化和反序列化破坏单例模式</strong><br><strong>反射破坏单例模式</strong>：无参构造方法的反射破坏——懒汉式无法防御</p><p>反射防御</p><p>枚举类实现单例模式</p>]]></content:encoded>
      
      <comments>http://mhp.github.io/2019/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>线程池---骚操作</title>
      <link>http://mhp.github.io/2019/12/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E9%AA%9A%E6%93%8D%E4%BD%9C/</link>
      <guid>http://mhp.github.io/2019/12/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E9%AA%9A%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Wed, 11 Dec 2019 13:14:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;h2 id=&quot;效果对比&quot;&gt;&lt;a href=&quot;#效果对比&quot; class=&quot;headerlink&quot; title=&quot;效果对比&quot;&gt;&lt;/a&gt;效果对
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h2><ul><li>普通线程的启动方式</li><li>利用线程池启动线程的方式<br><a href="https://mhp8338.github.io/2019/12/11/hello-world/" target="_blank" rel="noopener">Writing</a></li></ul><h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h2><ul><li>降低资源消耗：不用频繁创建销毁资源。</li><li>提高响应速度</li><li>提高线程可管理性</li></ul><h2 id="简单线程池的设计"><a href="#简单线程池的设计" class="headerlink" title="简单线程池的设计"></a>简单线程池的设计</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><h3 id="设计过程中需要思考的问题"><a href="#设计过程中需要思考的问题" class="headerlink" title="设计过程中需要思考的问题"></a>设计过程中需要思考的问题</h3><ol><li>初始创建线程数</li><li>没有可用线程的解决策略</li><li>缓冲数组长度</li><li>缓冲数组满了怎么办？</li></ol><h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><ul><li>corePoolSize</li><li>maxiumPoolSize</li><li>keepAliveTime</li><li>unit</li><li>workQueue</li><li>threadFactory</li><li>handle</li></ul><h2 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h2><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><ul><li>无界队列（链表）</li><li>有界的队列（链表、数组）</li><li>同步移交队列</li></ul><h2 id="线程池可选择的饱和策略"><a href="#线程池可选择的饱和策略" class="headerlink" title="线程池可选择的饱和策略"></a>线程池可选择的饱和策略</h2><ul><li>AbortPolicy终止策略(默认):抛异常，拒绝新任务</li><li>DiscardPolicy抛弃策略：抛弃新任务</li><li>DiscardOldestPolicy抛弃旧任务的策略：扔掉最旧的任务，添加新的任务</li><li>CallerRunsPolicy调用者运行的策略：提交任务的一方执行操作</li></ul><h2 id="线程池执行的示意图"><a href="#线程池执行的示意图" class="headerlink" title="线程池执行的示意图"></a>线程池执行的示意图</h2><h2 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h2><pre><code>Executors.newSingleThreadExecutor() //单一线程线程池Executors.newCachedThreadPool() //线程数量无限线程池Executors.newFixedThreadPool( 10 ) //线程数量固定的线程池</code></pre><h2 id="向线程池提交任务的两种方式"><a href="#向线程池提交任务的两种方式" class="headerlink" title="向线程池提交任务的两种方式"></a>向线程池提交任务的两种方式</h2><ul><li>submit()</li><li>execute() 无法将值返回给主线程</li></ul><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><ul><li>RUNNING</li><li>SHUTDOWN</li><li>STOP</li><li>TIDYING</li><li>TERMINATED</li></ul>]]></content:encoded>
      
      <comments>http://mhp.github.io/2019/12/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E9%AA%9A%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vim</title>
      <link>http://mhp.github.io/2019/05/27/vim/</link>
      <guid>http://mhp.github.io/2019/05/27/vim/</guid>
      <pubDate>Mon, 27 May 2019 01:50:37 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;（一）初始-vim&quot;&gt;&lt;a href=&quot;#（一）初始-vim&quot; class=&quot;headerlink&quot; title=&quot;（一）初始 vim&quot;&gt;&lt;/a&gt;（一）初始 vim&lt;/h1&gt;&lt;h2 id=&quot;1-1-vim-编辑插入模式&quot;&gt;&lt;a href=&quot;#1-1-vim-编辑插
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="（一）初始-vim"><a href="#（一）初始-vim" class="headerlink" title="（一）初始 vim"></a>（一）初始 vim</h1><h2 id="1-1-vim-编辑插入模式"><a href="#1-1-vim-编辑插入模式" class="headerlink" title="1.1 vim 编辑插入模式"></a>1.1 vim 编辑插入模式</h2><p>insert-&gt;normal:<code>esc</code><br>normal-&gt;insert:</p><ul><li><code>i:insert</code>光标前插入</li><li><code>a:append</code>光标后插入</li><li><code>o:open a line below</code>当前行的下一行插入</li><li><code>A:append after line</code>当前行最后插入</li><li><code>I:insert before line</code>当前行最前方插入</li><li><code>O:append a line above</code>当前行的上一行插入</li></ul><p>保存和退出:<code>wq</code></p><h2 id="1-2-vim-的多种模式"><a href="#1-2-vim-的多种模式" class="headerlink" title="1.2 vim 的多种模式"></a>1.2 vim 的多种模式</h2><ul><li>normal:<ul><li>各种命令操作和移动</li><li>大部分情况下在浏览而不是编辑</li></ul></li><li>insert：</li><li>command:<ul><li>保存和关闭<code>:wq</code></li><li>分屏：<code>:vs</code>(竖分屏 vertical screen) <code>:sp</code>(横分屏 split)</li><li>全局替换：<code>:s/foo/bar/g</code>-&gt;<code>:s/python/java/g</code></li></ul></li><li>visual:<ul><li>Normal 模式下<code>v</code>进入 visual</li><li>使用<code>V</code>选择行</li><li><code>ctrl+v</code>块状选择文本</li></ul></li></ul><h2 id="1-3-vim-插入模式技巧"><a href="#1-3-vim-插入模式技巧" class="headerlink" title="1.3 vim 插入模式技巧"></a>1.3 vim 插入模式技巧</h2><p><code>ctrl+h</code>:删除上一个字符<br><code>ctrl+w</code>:删除上一个单词<br><code>ctrl+u</code>:删除当前行<br><code>ctrl+[</code>:切换 esc<br><code>gi</code>:快速跳转到最后一次编辑的地方进入插入模式</p><h2 id="1-4-vim-快速移动"><a href="#1-4-vim-快速移动" class="headerlink" title="1.4 vim 快速移动"></a>1.4 vim 快速移动</h2><p><code>w/W</code>移动到下一个 word/WORD 开头<br><code>e/E</code>移动到下一个 word/WORD 结尾<br><code>b/B</code>移动到上一个 word/WORD 开头<br>WORD 以空白符分割的单词，word 以非空白符分割的单词<br>行间搜索移动：</p><ul><li><code>f/F</code>跳转到目标字符(前面搜索/后边搜索)</li><li><code>;/,</code>搜寻到下一个/上一个<br>水平移动:</li><li><code>0</code><strong>移动到行首</strong>，<code>^</code>移动到第一非空白字符=<strong><code>0+w</code></strong></li><li><code>$</code><strong>移动到行尾</strong>，<code>g_</code>移动到行尾非空白字符</li></ul><p>垂直移动：</p><ul><li><code>(</code>和<code>)</code>句子之间移动</li><li><code>{</code>和<code>}</code>段落之间移动</li></ul><p>页面移动：</p><ul><li><code>gg/G</code>移动到文件的开头和结尾，<code>ctrl+o</code>快速返回</li><li><code>H/M/L</code>跳转到屏幕的开头(Head)、中间(Middle)和结尾(Lower)</li><li><code>ctrl+u/f</code>上下翻页(upword,forword)</li><li><code>zz</code>把屏幕置于中间</li></ul><h2 id="1-5-vim的增删改查"><a href="#1-5-vim的增删改查" class="headerlink" title="1.5 vim的增删改查"></a>1.5 vim的增删改查</h2><h3 id="1-5-1-vim增加字符"><a href="#1-5-1-vim增加字符" class="headerlink" title="1.5.1 vim增加字符"></a>1.5.1 vim增加字符</h3><ul><li>增加字符就是插入模式</li><li>iao</li><li>IAO<h3 id="1-5-2-vim删减"><a href="#1-5-2-vim删减" class="headerlink" title="1.5.2 vim删减"></a>1.5.2 vim删减</h3></li><li>x也可以删除</li><li>daw删除单词</li><li>diw不删除空格</li><li>dd删除行</li><li>dt)删除右括号里的内容 </li><li>d配合visual模式的使用<h3 id="1-5-3-vim快速修改"><a href="#1-5-3-vim快速修改" class="headerlink" title="1.5.3 vim快速修改"></a>1.5.3 vim快速修改</h3>常用有三个：</li><li>c(change):配合文本删除字符进入插入模式<code>c+(a)+w</code> <code>C</code> <code>ctg</code></li><li>r(replace):快速修改</li><li>s(substitude):删除当前字符进入插入模式<h3 id="1-5-4-vim快速查询"><a href="#1-5-4-vim快速查询" class="headerlink" title="1.5.4 vim快速查询"></a>1.5.4 vim快速查询</h3>查询单词也是一种常用操作：</li><li>使用<code>\</code>或者<code>?</code>进行前向或者反向操作</li><li>使用<code>n</code>或者<code>N</code>跳转下一个或者上一个匹配</li><li>使用<code>*</code>或者<code>#</code>进行当前单词的前向和后向匹配 <h2 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h2></li></ul><p>vimrc 的几点说明：</p><ul><li>vimrc=vim run command</li><li>系统级 vimrc 和用户级 vimrc<ul><li>系统级：所用用户都生效</li><li>用户级：不同用户命令生效状态不同</li><li>每一行作为一个命令而执行</li></ul></li></ul><h2 id="vim删除"><a href="#vim删除" class="headerlink" title="vim删除"></a>vim删除</h2><ul><li><code>d$</code>删除光标后的改行部分</li></ul>]]></content:encoded>
      
      <comments>http://mhp.github.io/2019/05/27/vim/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java MySQL</title>
      <link>http://mhp.github.io/2019/05/26/Java-MySQL/</link>
      <guid>http://mhp.github.io/2019/05/26/Java-MySQL/</guid>
      <pubDate>Sun, 26 May 2019 07:49:56 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;MySQL-数据库的简介&quot;&gt;&lt;a href=&quot;#MySQL-数据库的简介&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据库的简介&quot;&gt;&lt;/a&gt;MySQL 数据库的简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-MySQL-数据库的简介和安装&quot;&gt;&lt;a h
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="MySQL-数据库的简介"><a href="#MySQL-数据库的简介" class="headerlink" title="MySQL 数据库的简介"></a>MySQL 数据库的简介</h1><h2 id="1-1-MySQL-数据库的简介和安装"><a href="#1-1-MySQL-数据库的简介和安装" class="headerlink" title="1.1 MySQL 数据库的简介和安装"></a>1.1 MySQL 数据库的简介和安装</h2><h3 id="1-1-1-什么是数据库？"><a href="#1-1-1-什么是数据库？" class="headerlink" title="1.1.1 什么是数据库？"></a>1.1.1 什么是数据库？</h3><p>数据库是按数据结构来组织、存储和管理数据的仓库</p><h3 id="1-1-1-常见数据库"><a href="#1-1-1-常见数据库" class="headerlink" title="1.1.1 常见数据库"></a>1.1.1 常见数据库</h3><p>(甲骨文)Oracle、(IBM)DB2、(微软)SQL Server、Postgre SQL、MySQL。<br>MySQL 是典型的关系型数据管理系统</p><h3 id="1-1-2-相关术语"><a href="#1-1-2-相关术语" class="headerlink" title="1.1.2 相关术语"></a>1.1.2 相关术语</h3><p>数据库系统<code>Database System</code>简称 DBS，包含以下部分：</p><ul><li>数据库<code>Database</code></li><li>数据库管理系统<code>Database Manage System</code>DBMS</li><li>应用开发工具</li><li>管理员及用户</li></ul><h3 id="1-1-3-SQL-语言"><a href="#1-1-3-SQL-语言" class="headerlink" title="1.1.3 SQL 语言"></a>1.1.3 SQL 语言</h3><p>SQL(结构化查询语言 Structured Query Language)</p><ul><li>DDL:数据定义语言</li><li>DML:数据操控语言<ul><li>增</li><li>删</li><li>改</li></ul></li><li>DQL:数据查询语言<ul><li>查询用户</li></ul></li><li>DCL:数据控制语言<ul><li>控制用户权限</li></ul></li></ul><h2 id="1-2-MySQL-相关操作"><a href="#1-2-MySQL-相关操作" class="headerlink" title="1.2 MySQL 相关操作"></a>1.2 MySQL 相关操作</h2><h3 id="1-2-1-配置文件"><a href="#1-2-1-配置文件" class="headerlink" title="1.2.1 配置文件"></a>1.2.1 配置文件</h3><ul><li>隐藏文件</li><li>my.conf</li></ul><h3 id="1-2-2-登陆-退出-MySQL"><a href="#1-2-2-登陆-退出-MySQL" class="headerlink" title="1.2.2 登陆/退出 MySQL"></a>1.2.2 登陆/退出 MySQL</h3><p>登陆：</p><ul><li><code>mysql -uroot -p</code></li><li><code>mysql -uroot -p0623</code></li></ul><p>退出:</p><ul><li><code>exit</code></li><li><code>quit</code></li></ul><p>版本：</p><ul><li><code>mysql -V</code></li><li><code>mysql --version</code></li></ul><p>登陆信息中需要掌握：</p><ul><li>登陆过后命令行的结束符使用<code>;</code>或者是<code>\g</code></li><li>可以通过<code>help</code>、<code>\h</code>或<code>?</code>配合关键字查看帮助手册 </li><li><code>\c</code>可以取消当前命令的执行：<code>select user() \c</code></li></ul><h2 id="1-2-3-常用的SQL语句"><a href="#1-2-3-常用的SQL语句" class="headerlink" title="1.2.3 常用的SQL语句"></a>1.2.3 常用的SQL语句</h2><p><code>SELECT USER()</code>:得到登陆的用户<br><code>SELECT VERSION()</code>:得到mysql的版本信息<br><code>SELECT NOW()</code>:得到当前的日期时间<br><code>SELECT DATABASE()</code>:得到当前打开的数据</p><h2 id="1-2-4-SQL语句的语法规范"><a href="#1-2-4-SQL语句的语法规范" class="headerlink" title="1.2.4 SQL语句的语法规范"></a>1.2.4 SQL语句的语法规范</h2><ul><li>常用关键字需要大写，库名、表名和字段名称等需要小写</li><li>支持拆行操作，但不能把完整的单词拆开</li><li>数据库名称，表名称和字段名称不使用MySQL的保留字，如果必须使用<code>&#39;&#39;</code>将其括起来</li></ul>]]></content:encoded>
      
      <comments>http://mhp.github.io/2019/05/26/Java-MySQL/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Learing Git</title>
      <link>http://mhp.github.io/2019/05/23/Learing-Git/</link>
      <guid>http://mhp.github.io/2019/05/23/Learing-Git/</guid>
      <pubDate>Thu, 23 May 2019 01:48:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;创建-Git-版本库&quot;&gt;&lt;a href=&quot;#创建-Git-版本库&quot; class=&quot;headerlink&quot; title=&quot;创建 Git 版本库&quot;&gt;&lt;/a&gt;创建 Git 版本库&lt;/h1&gt;&lt;p&gt;版本库就是一个目录，在该目录下所有文件都受 Git 的管理，Git 可以跟踪
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="创建-Git-版本库"><a href="#创建-Git-版本库" class="headerlink" title="创建 Git 版本库"></a>创建 Git 版本库</h1><p>版本库就是一个目录，在该目录下所有文件都受 Git 的管理，Git 可以跟踪每个文件的修改和删除，任何时刻都可以追踪和还原。<br>具体过程如下：</p><ul><li>创建空目录<pre><code>  mkdir learngit  cd learngit</code></pre></li><li>将该目录变成 Git 所管理的仓库<pre><code>git init</code></pre></li><li>编写 readme.txt</li><li>把文件添加仓库缓存区<code>stage</code><pre><code>git add readme.txt</code></pre></li><li>提交更改，把缓存区内容提交至当前分支<code>master</code><pre><code>git commit -m &quot;wrote a readme file&quot;</code></pre><img src="https://i.loli.net/2019/05/23/5ce6857441eb128759.jpg" alt="0.jpg"></li></ul><h1 id="修改-git-文件"><a href="#修改-git-文件" class="headerlink" title="修改 git 文件"></a>修改 git 文件</h1><ul><li>修改 readme.txt 文件</li><li>查看修改修改状态，但此时还未提交修改。并且只能显示已经修改，并未显示具体修改的内容<pre><code>git status</code></pre></li><li>查看具体修改的内容<pre><code>git diff</code></pre></li><li>添加<pre><code>git add readme.txtgit commit -m &quot;add distritbuted&quot;</code></pre></li></ul><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><ul><li>查看历史记录<pre><code>git loggit log --pretty=oneline</code></pre></li><li>回退版本<pre><code>git reset --hard Head^git reset --hard Head~100</code></pre></li><li>还原版本<pre><code>git reset --hard {commit id}</code></pre></li><li>查看文件<pre><code>cat readme.txt</code></pre></li><li><p>查找之前每一次命令</p><pre><code>git reflog</code></pre><h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1></li><li><p>提交缓存区</p><p><img src="https://i.loli.net/2019/05/23/5ce686ef3473670281.jpg" alt="1.jpg"></p></li><li><p>提交分支</p><p><img src="https://i.loli.net/2019/05/23/5ce6873f35e5257129.jpg" alt="2.jpg"></p></li></ul><blockquote><p>git管理修改，并非管理文件。<br>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p></blockquote>]]></content:encoded>
      
      <comments>http://mhp.github.io/2019/05/23/Learing-Git/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
